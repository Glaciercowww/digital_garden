<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>改进版全景图像拼接工具</title>
    <!-- 修改加载方式，添加onload和onerror回调 -->
    <script src="/libs/opencv.js" onload="onOpenCVLoaded()" onerror="handleOpenCVError()"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .upload-section {
            border: 2px dashed #3498db;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        .image-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        .preview-item {
            position: relative;
            width: 200px;
            margin-bottom: 15px;
        }
        .preview-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .result-section {
            margin-top: 30px;
            display: none;
        }
        .result-section img {
            max-width: 100%;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .instructions {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            color: #3498db;
        }
        .debug-section {
            margin-top: 20px;
            display: none;
        }
        .debug-canvas {
            max-width: 100%;
            margin: 10px 0;
            border: 1px solid #ddd;
        }
        .controls-section {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        .control-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .control-group label {
            width: 200px;
            font-weight: bold;
        }
        .image-order {
            display: flex;
            align-items: center;
            margin-top: 5px;
            justify-content: center;
        }
        .order-btn {
            background-color: #e0e0e0;
            border: none;
            width: 24px;
            height: 24px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 3px;
        }
        .order-label {
            font-weight: bold;
        }
        footer {
            margin-top: 40px;
            text-align: center;
            color: #7f8c8d;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>改进版全景图像拼接工具</h1>
        
        <div class="instructions">
            <h2>使用说明</h2>
            <ol>
                <li>上传2张或以上需要拼接的图像（请按从左到右的顺序上传或调整顺序）</li>
                <li>可以调整参数以获得更好的拼接效果</li>
                <li>点击"开始拼接"按钮进行图像拼接</li>
                <li>处理完成后，可以预览并下载拼接结果</li>
            </ol>
        </div>
        
        <div id="opencvStatus" class="status">正在加载OpenCV.js，请稍候...</div>
        
        <div class="upload-section">
            <p>上传需要拼接的图像（按从左到右的顺序）</p>
            <input type="file" id="fileInput" accept="image/*" multiple>
            <button class="btn" id="uploadBtn">选择文件</button>
        </div>
        
        <div class="image-preview" id="imagePreview"></div>
        
        <div class="controls-section">
            <h3>高级参数设置</h3>
            <div class="control-group">
                <label for="ratioSlider">Lowe比率测试阈值:</label>
                <input type="range" id="ratioSlider" min="50" max="95" value="75" step="5">
                <span id="ratioValue">0.75</span>
            </div>
            <div class="control-group">
                <label for="reprojThreshSlider">RANSAC重投影阈值:</label>
                <input type="range" id="reprojThreshSlider" min="10" max="100" value="40" step="5">
                <span id="reprojThreshValue">4.0</span>
            </div>
            <div class="control-group">
                <label for="detectorSelect">特征检测器:</label>
                <select id="detectorSelect">
                    <option value="orb">ORB (快速)</option>
                    <option value="sift" selected>SIFT (准确)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="showDebugInfo">显示调试信息:</label>
                <input type="checkbox" id="showDebugInfo">
            </div>
        </div>
        
        <div style="text-align: center;">
            <button class="btn" id="stitchBtn" disabled>开始拼接</button>
            <button class="btn" id="clearBtn">清除所有图像</button>
            <button class="btn" id="downloadBtn" style="display: none;">下载全景图</button>
        </div>
        
        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            <p id="processingStatus">正在拼接图像，请稍候...</p>
        </div>
        
        <div class="debug-section" id="debugSection">
            <h3>调试信息</h3>
            <div id="featuresContainer"></div>
            <div id="matchesContainer"></div>
        </div>
        
        <div class="result-section" id="resultSection">
            <h2>拼接结果</h2>
            <img id="resultImage" alt="全景拼接结果">
        </div>
    </div>
    
    <footer>
        <p>© 2025 全景图像拼接工具 | 基于OpenCV.js实现</p>
    </footer>

    <script>
        // 全局变量
        let uploadedImages = [];
        let cvReady = false;
        
        // DOM元素
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const imagePreview = document.getElementById('imagePreview');
        const stitchBtn = document.getElementById('stitchBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const resultSection = document.getElementById('resultSection');
        const resultImage = document.getElementById('resultImage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const processingStatus = document.getElementById('processingStatus');
        const opencvStatus = document.getElementById('opencvStatus');
        const debugSection = document.getElementById('debugSection');
        const featuresContainer = document.getElementById('featuresContainer');
        const matchesContainer = document.getElementById('matchesContainer');
        
        // 控制元素
        const ratioSlider = document.getElementById('ratioSlider');
        const ratioValue = document.getElementById('ratioValue');
        const reprojThreshSlider = document.getElementById('reprojThreshSlider');
        const reprojThreshValue = document.getElementById('reprojThreshValue');
        const detectorSelect = document.getElementById('detectorSelect');
        const showDebugInfo = document.getElementById('showDebugInfo');

        // OpenCV.js加载错误处理
        function handleOpenCVError() {
            const status = document.getElementById('opencvStatus');
            status.textContent = 'OpenCV.js加载失败! 请刷新页面或联系管理员。';
            status.style.color = 'red';
        }

        // OpenCV.js加载成功回调
        function onOpenCVLoaded() {
            const status = document.getElementById('opencvStatus');
            status.textContent = 'OpenCV.js已加载完成！';
            status.style.color = 'green';
            cvReady = true;
            updateStitchButtonState();
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
        
        // 更新滑块显示值
        ratioSlider.addEventListener('input', () => {
            const value = ratioSlider.value / 100;
            ratioValue.textContent = value.toFixed(2);
        });
        
        reprojThreshSlider.addEventListener('input', () => {
            const value = reprojThreshSlider.value / 10;
            reprojThreshValue.textContent = value.toFixed(1);
        });
        
        // 显示/隐藏调试信息
        showDebugInfo.addEventListener('change', () => {
            debugSection.style.display = showDebugInfo.checked ? 'block' : 'none';
        });
        
        // 事件监听
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        clearBtn.addEventListener('click', clearAllImages);
        stitchBtn.addEventListener('click', startStitching);
        downloadBtn.addEventListener('click', downloadResult);
        
        // 更新拼接按钮状态
        function updateStitchButtonState() {
            stitchBtn.disabled = uploadedImages.length < 2 || !cvReady;
        }
        
        // 处理文件选择
        function handleFileSelect(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
            
            if (imageFiles.length === 0) {
                alert('请选择有效的图像文件');
                return;
            }
            
            // 添加到上传图像数组
            let loadedCount = 0;
            imageFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedImages.push({
                        file: file,
                        src: e.target.result,
                        name: file.name
                    });
                    
                    loadedCount++;
                    if (loadedCount === imageFiles.length) {
                        // 只有当所有图像加载完成后才更新预览
                        updateImagePreview();
                    }
                };
                reader.readAsDataURL(file);
            });
        }
        
        // 更新图像预览
        function updateImagePreview() {
            imagePreview.innerHTML = '';
            
            uploadedImages.forEach((img, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                
                const imgElement = document.createElement('img');
                imgElement.src = img.src;
                imgElement.alt = img.name;
                imgElement.title = img.name;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '×';
                removeBtn.title = '移除图像';
                removeBtn.onclick = (e) => {
                    e.stopPropagation(); // 防止事件冒泡
                    removeImage(index);
                };
                
                previewItem.appendChild(imgElement);
                previewItem.appendChild(removeBtn);
                
                // 添加顺序控制按钮
                const orderControls = document.createElement('div');
                orderControls.className = 'image-order';
                
                const leftBtn = document.createElement('button');
                leftBtn.className = 'order-btn';
                leftBtn.innerHTML = '←';
                leftBtn.title = '向左移动';
                leftBtn.disabled = index === 0;
                leftBtn.onclick = (e) => {
                    e.stopPropagation(); // 防止事件冒泡
                    moveImage(index, index - 1);
                };
                
                const orderLabel = document.createElement('span');
                orderLabel.className = 'order-label';
                orderLabel.textContent = index + 1;
                
                const rightBtn = document.createElement('button');
                rightBtn.className = 'order-btn';
                rightBtn.innerHTML = '→';
                rightBtn.title = '向右移动';
                rightBtn.disabled = index === uploadedImages.length - 1;
                rightBtn.onclick = (e) => {
                    e.stopPropagation(); // 防止事件冒泡
                    moveImage(index, index + 1);
                };
                
                orderControls.appendChild(leftBtn);
                orderControls.appendChild(orderLabel);
                orderControls.appendChild(rightBtn);
                
                previewItem.appendChild(orderControls);
                
                imagePreview.appendChild(previewItem);
            });
            
            // 更新拼接按钮状态
            updateStitchButtonState();
        }
        
        // 移除图像
        function removeImage(index) {
            uploadedImages.splice(index, 1);
            updateImagePreview();
        }
        
        // 调整图像顺序
        function moveImage(fromIndex, toIndex) {
            if (toIndex < 0 || toIndex >= uploadedImages.length) return;
            
            const temp = uploadedImages[fromIndex];
            uploadedImages[fromIndex] = uploadedImages[toIndex];
            uploadedImages[toIndex] = temp;
            
            updateImagePreview();
        }
        
        // 清除所有图像
        function clearAllImages() {
            uploadedImages = [];
            updateImagePreview();
            resultSection.style.display = 'none';
            downloadBtn.style.display = 'none';
            debugSection.style.display = 'none';
            featuresContainer.innerHTML = '';
            matchesContainer.innerHTML = '';
        }
        
        // 开始拼接处理
        function startStitching() {
            if (uploadedImages.length < 2 || !cvReady) {
                alert('请至少上传2张图像，并确保OpenCV.js已加载完成');
                return;
            }
            
            // 获取参数设置
            const ratio = ratioSlider.value / 100;
            const reprojThresh = reprojThreshSlider.value / 10;
            const detectorType = detectorSelect.value;
            const showDebug = showDebugInfo.checked;
            
            // 显示加载指示器
            loadingIndicator.style.display = 'block';
            stitchBtn.disabled = true;
            resultSection.style.display = 'none';
            downloadBtn.style.display = 'none';
            debugSection.style.display = showDebug ? 'block' : 'none';
            featuresContainer.innerHTML = '';
            matchesContainer.innerHTML = '';
            
            // 预加载图像
            const imageElements = [];
            let loadedCount = 0;
            
            uploadedImages.forEach((imgData, index) => {
                const img = new Image();
                img.onload = function() {
                    loadedCount++;
                    if (loadedCount === uploadedImages.length) {
                        // 所有图像加载完成，开始拼接
                        processPanoramaStitching(imageElements, ratio, reprojThresh, detectorType, showDebug);
                    }
                };
                img.onerror = function() {
                    loadingIndicator.style.display = 'none';
                    stitchBtn.disabled = false;
                    alert(`图像 ${index + 1} 加载失败`);
                };
                img.src = imgData.src;
                imageElements.push(img);
            });
        }
        
     // 处理全景拼接
function processPanoramaStitching(imageElements, ratio, reprojThresh, detectorType, showDebug) {
    try {
        // 显示进度状态
        processingStatus.textContent = '正在加载图像...';
        
        // 将HTML图像元素转换为OpenCV矩阵
        const cvImages = [];
        for (let i = 0; i < imageElements.length; i++) {
            processingStatus.textContent = `处理图像 ${i+1}/${imageElements.length}...`;
            const img = imageElements[i];
            const mat = cv.imread(img);
            cvImages.push(mat);
        }
        
        // 开始拼接过程
        processingStatus.textContent = '开始拼接图像...';
        const result = stitchImages(cvImages, ratio, reprojThresh, detectorType, showDebug);
        
        // 显示结果
        processingStatus.textContent = '拼接完成！';
        cv.imshow('resultImage', result);
        resultSection.style.display = 'block';
        downloadBtn.style.display = 'inline-block';
        
        // 释放内存
        cvImages.forEach(mat => mat.delete());
        result.delete();
        
        // 完成后关闭加载指示器
        loadingIndicator.style.display = 'none';
        stitchBtn.disabled = false;
        
    } catch (error) {
        console.error('拼接过程出错:', error);
        processingStatus.textContent = '拼接失败: ' + error.message;
        loadingIndicator.style.display = 'none';
        stitchBtn.disabled = false;
    }
}

// 实现基于全景2.py的图像拼接算法
function stitchImages(images, ratio, reprojThresh, detectorType, showDebug) {
    if (images.length < 2) {
        throw new Error('至少需要两张图像进行拼接');
    }
    
    // 以第一张图像为基准，依次拼接
    let result = images[0].clone();
    let vis_list = [];
    
    // 逐一拼接每张图像
    for (let i = 1; i < images.length; i++) {
        processingStatus.textContent = `拼接图像 ${i} 和已拼接结果...`;
        
        // 检测特征点并描述
        const featuresResult = detectAndDescribe(result, detectorType);
        const featuresNext = detectAndDescribe(images[i], detectorType);
        
        // 匹配特征点
        const M = matchKeypoints(
            featuresNext.keypoints, 
            featuresResult.keypoints,
            featuresNext.descriptors, 
            featuresResult.descriptors,
            ratio, 
            reprojThresh
        );
        
        // 如果匹配失败，跳过这张图像
        if (!M) {
            console.warn(`图像 ${i} 与已拼接结果匹配失败，跳过...`);
            continue;
        }
        
        // 应用透视变换拼接图像
        const [matches, H, status] = M;
        
        // 计算变换后的图像大小和偏移
        const h_result = result.rows;
        const w_result = result.cols;
        const h_next = images[i].rows;
        const w_next = images[i].cols;
        
        // 创建变换后的图像边界点
        const pts1 = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, 0, h_result, w_result, h_result, w_result, 0]);
        const pts2 = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, 0, h_next, w_next, h_next, w_next, 0]);
        
        // 应用变换矩阵到图像边界点
        const pts2_ = new cv.Mat();
        cv.perspectiveTransform(pts2, pts2_, H);
        
        // 合并两组点
        const pts = new cv.Mat();
        cv.vconcat([pts1, pts2_], pts);
        
        // 计算变换后的图像边界
        let minPoint = new cv.Point(Number.MAX_VALUE, Number.MAX_VALUE);
        let maxPoint = new cv.Point(Number.MIN_VALUE, Number.MIN_VALUE);
        
        // 找出所有点的最小和最大x,y值
        for (let j = 0; j < pts.rows; j++) {
            const x = pts.data32F[j * 2];
            const y = pts.data32F[j * 2 + 1];
            minPoint.x = Math.min(minPoint.x, x);
            minPoint.y = Math.min(minPoint.y, y);
            maxPoint.x = Math.max(maxPoint.x, x);
            maxPoint.y = Math.max(maxPoint.y, y);
        }
        
        // 平移矩阵
        const t = [Math.ceil(-minPoint.x), Math.ceil(-minPoint.y)];
        const Ht = cv.matFromArray(3, 3, cv.CV_64F, [
            1, 0, t[0],
            0, 1, t[1],
            0, 0, 1
        ]);
        
        // 创建单位矩阵
        const I = cv.Mat.eye(3, 3, cv.CV_64F);
        
        // 应用变换
        const HtI = new cv.Mat();
        cv.matMul(Ht, I, HtI);
        
        const HtH = new cv.Mat();
        cv.matMul(Ht, H, HtH);
        
        // 计算新图像尺寸
        const width = Math.ceil(maxPoint.x - minPoint.x);
        const height = Math.ceil(maxPoint.y - minPoint.y);
        
        // 应用变换，创建全景图
        const result_warped = new cv.Mat();
        const next_warped = new cv.Mat();
        
        cv.warpPerspective(result, result_warped, HtI, new cv.Size(width, height));
        cv.warpPerspective(images[i], next_warped, HtH, new cv.Size(width, height));
        
        // 创建掩码，用于融合图像
        const mask = new cv.Mat.zeros(height, width, cv.CV_8U);
        const ones = new cv.Mat(h_next, w_next, cv.CV_8U, new cv.Scalar(1));
        const mask_warped = new cv.Mat();
        cv.warpPerspective(ones, mask_warped, HtH, new cv.Size(width, height));
        
        // 融合图像
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (mask_warped.ucharPtr(y, x)[0] > 0) {
                    // 将next_warped的像素复制到result_warped
                    const resultPtr = result_warped.ucharPtr(y, x);
                    const nextPtr = next_warped.ucharPtr(y, x);
                    
                    resultPtr[0] = nextPtr[0]; // B
                    resultPtr[1] = nextPtr[1]; // G
                    resultPtr[2] = nextPtr[2]; // R
                }
            }
        }
        
        // 释放之前的结果，更新为新结果
        result.delete();
        result = result_warped.clone();
        
        // 如果需要显示匹配结果并且开启了调试
        if (showDebug) {
            const vis = drawMatches(images[i], result, 
                                  featuresNext.keypoints, featuresResult.keypoints, 
                                  matches, status);
            // 添加到可视化列表并显示
            if (vis) {
                const canvasId = `matchCanvas${i}`;
                const canvas = document.createElement('canvas');
                canvas.id = canvasId;
                canvas.className = 'debug-canvas';
                
                const title = document.createElement('h4');
                title.textContent = `图像 ${i} 和已拼接结果的匹配`;
                
                matchesContainer.appendChild(title);
                matchesContainer.appendChild(canvas);
                
                cv.imshow(canvasId, vis);
                vis.delete();
            }
        }
        
        // 释放内存
        pts1.delete();
        pts2.delete();
        pts2_.delete();
        pts.delete();
        HtI.delete();
        HtH.delete();
        Ht.delete();
        I.delete();
        next_warped.delete();
        mask.delete();
        ones.delete();
        mask_warped.delete();
        
        if (featuresResult.keypoints) featuresResult.keypoints.delete();
        if (featuresResult.descriptors) featuresResult.descriptors.delete();
        if (featuresNext.keypoints) featuresNext.keypoints.delete();
        if (featuresNext.descriptors) featuresNext.descriptors.delete();
    }
    
    return result;
}

// 特征检测和描述函数（对应Python中的detectAndDescribe方法）
function detectAndDescribe(image, detectorType) {
    // 转换图像为灰度
    const gray = new cv.Mat();
    cv.cvtColor(image, gray, cv.COLOR_BGR2GRAY);
    
    let keypoints = new cv.KeyPointVector();
    let descriptors = new cv.Mat();
    
    // 根据选择使用不同的特征检测器
    if (detectorType === 'sift') {
        // 使用SIFT
        const sift = new cv.SIFT();
        sift.detect(gray, keypoints);
        sift.compute(gray, keypoints, descriptors);
    } else {
        // 使用ORB (默认)
        const orb = new cv.ORB(500);
        orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);
    }
    
    // 释放内存
    gray.delete();
    
    return {
        keypoints: keypoints,
        descriptors: descriptors
    };
}

// 特征点匹配函数（对应Python中的matchKeypoints方法）
function matchKeypoints(kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh) {
    // 创建特征匹配器
    const matcher = new cv.BFMatcher(cv.NORM_L2);
    const matches = new cv.DMatchVector();
    
    // 进行knn匹配
    const knnMatches = new cv.DMatchVectorVector();
    matcher.knnMatch(featuresA, featuresB, knnMatches, 2);
    
    // 应用Lowe的比率测试
    const goodMatches = [];
    const status = [];
    
    for (let i = 0; i < knnMatches.size(); i++) {
        if (knnMatches.get(i).size() >= 2) {
            const m = knnMatches.get(i).get(0);
            const n = knnMatches.get(i).get(1);
            
            if (m.distance < n.distance * ratio) {
                goodMatches.push(m);
                matches.push_back(m);
                status.push(1);
            } else {
                status.push(0);
            }
        }
    }
    
    // 需要至少4个匹配点才能计算单应性矩阵
    if (goodMatches.length >= 4) {
        // 构建两组点
        const srcPoints = [];
        const dstPoints = [];
        
        for (let i = 0; i < goodMatches.length; i++) {
            const trainIdx = goodMatches[i].trainIdx;
            const queryIdx = goodMatches[i].queryIdx;
            
            // 获取对应的关键点
            const ptA = new cv.Point(
                kpsA.get(queryIdx).pt.x, 
                kpsA.get(queryIdx).pt.y
            );
            const ptB = new cv.Point(
                kpsB.get(trainIdx).pt.x, 
                kpsB.get(trainIdx).pt.y
            );
            
            srcPoints.push(ptA.x, ptA.y);
            dstPoints.push(ptB.x, ptB.y);
        }
        
        // 转换为OpenCV矩阵
        const srcPointsMat = cv.matFromArray(goodMatches.length, 1, cv.CV_32FC2, srcPoints);
        const dstPointsMat = cv.matFromArray(goodMatches.length, 1, cv.CV_32FC2, dstPoints);
        
        // 计算单应性矩阵
        const mask = new cv.Mat();
        const H = cv.findHomography(srcPointsMat, dstPointsMat, cv.RANSAC, reprojThresh, mask);
        
        // 释放内存
        srcPointsMat.delete();
        dstPointsMat.delete();
        
        // 返回匹配结果
        return [matches, H, status];
    }
    
    // 释放内存
    knnMatches.delete();
    
    // 匹配失败
    return null;
}

// 绘制特征点匹配结果（对应Python中的drawMatches方法）
function drawMatches(imageA, imageB, kpsA, kpsB, matches, status) {
    try {
        // 获取图像尺寸
        const hA = imageA.rows;
        const wA = imageA.cols;
        const hB = imageB.rows;
        const wB = imageB.cols;
        
        // 创建可视化图像
        const vis = new cv.Mat.zeros(Math.max(hA, hB), wA + wB, cv.CV_8UC3);
        
        // 将两张图像放在可视化图像的左右两侧
        const leftRect = new cv.Rect(0, 0, wA, hA);
        const rightRect = new cv.Rect(wA, 0, wB, hB);
        
        imageA.copyTo(vis.roi(leftRect));
        imageB.copyTo(vis.roi(rightRect));
        
        // 绘制匹配线
        for (let i = 0; i < matches.size(); i++) {
            if (status[i] === 1) {
                // 获取匹配的关键点
                const m = matches.get(i);
                const queryIdx = m.queryIdx;
                const trainIdx = m.trainIdx;
                
                // 绘制匹配线
                const ptA = new cv.Point(
                    kpsA.get(queryIdx).pt.x, 
                    kpsA.get(queryIdx).pt.y
                );
                const ptB = new cv.Point(
                    kpsB.get(trainIdx).pt.x + wA, 
                    kpsB.get(trainIdx).pt.y
                );
                
                // 绘制线条
                cv.line(vis, ptA, ptB, [0, 255, 0, 255], 1);
            }
        }
        
        return vis;
    } catch (error) {
        console.error('绘制匹配出错:', error);
        return null;
    }
}

// 下载拼接结果
function downloadResult() {
    if (!resultImage.src) return;
    
    const link = document.createElement('a');
    link.download = 'panorama_result.jpg';  // 修改为.jpg格式
    link.href = resultImage.src;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
        // 检测OpenCV.js是否已加载
        if (typeof cv !== 'undefined') {
            // 如果页面加载时已经加载了OpenCV，直接调用加载完成函数
            onOpenCVLoaded();
        } else {
            // 否则等待script标签中的onload回调触发
            opencvStatus.textContent = '正在加载OpenCV.js，请稍候...';
        }
    </script>
</body>
</html>
